# Roadmap Maestro del Backend de LifeBit (v2.0 - Documento Vivo)

# =================================================================================
# ||                                    ESTADO                                   ||
# =================================================================================
# || Leyenda:                                                                    ||
# || [x] Tarea Completada                                                        ||
# || [~] Tarea en Progreso o Parcialmente Completada                             ||
# || [ ] Tarea Pendiente                                                         ||
# =================================================================================

# =================================================================================
# ||     Epopeya 0: Fundación del Proyecto (CORE)     `[COMPLETADA]`             ||
# =================================================================================
# || Objetivo: Establecer una base de código robusta, segura y escalable.        ||
# ---------------------------------------------------------------------------------
*   `[x]` **CORE-01:** Estructura de carpetas profesional y modular.
*   `[x]` **CORE-02:** Conexión a la base de datos PostgreSQL (con pool).
*   `[x]` **CORE-03:** Servidor Express y middlewares base (`morgan`, `express.json`).
*   `[x]` **CORE-04:** Manejo de variables de entorno (`dotenv`).
*   `[x]` **CORE-05:** Manejador de errores global centralizado (`errorHandler`).
*   `[x]` **CORE-06:** Scripts de inicialización de BD (`init.js`, `setup.js`).

# =================================================================================
# ||     Epopeya 1: Autenticación y Ciclo de Vida del Usuario     `[EN PROGRESO]`  ||
# =================================================================================
# || Objetivo: Construir todos los mecanismos para que los usuarios puedan       ||
# ||           entrar, salir, gestionar sus cuentas e invitar a otros.           ||
# ---------------------------------------------------------------------------------
*   `[x]` **AUTH-01:** Modelo de datos MVP (`rol` y `id_*_actual` en `usuarios` - ADR-001).
*   `[x]` **AUTH-02:** Login tradicional (`POST /api/auth/login`).
*   `[x]` **AUTH-03:** Generación de JWT (`accessToken` y `refreshToken`).
*   `[x]` **AUTH-04:** Middlewares de seguridad (`protegeRuta` y `verificaRol`).
*   `[x]` **AUTH-05:** Servicio de envío de emails transaccionales (`Resend`).
*   `[x]` **AUTH-06:** Flujo de invitación con token y expiración.
*   `[x]` **AUTH-07:** Flujo de finalización de registro (`POST /api/auth/finalizar-registro`).
*   `[x]` **AUTH-08:** Flujo de invitación de Residentes por el Administrador.
    *   `[x]` Endpoint para invitación individual.
    *   `[x]` Endpoint para invitación masiva por archivo.
    *   `[x]` Worker que encola los trabajos de envio de email masivo.
*   `[x]` **AUTH-09:** CRUD completo de Residentes (Listar, Ver, Activar/Suspender).
*   `[x]` **AUTH-10:** Recuperación de contraseña (`forgot-password` y `reset-password`).
*   `[x]` **AUTH-11:** Cambio de contraseña para un usuario logueado.
*   `[x]` **AUTH-12 (Pospuesto):** Integración con Google (OAuth 2.0).
*   `[~]` **AUTH-13:** Flujo seguro para el cambio de dirección de email del usuario (con verificación al nuevo correo).
    *   `[x]` **AUTH-13.1:** Preparación de la Infraestructura.
        *   `[x]` Modificar la tabla usuarios añadiendo las columnas nuevo_email_pendiente, token_cambio_email y token_cambio_email_expira para manejar el estado transitorio del cambio.
        *   `[x]` Crear dos nuevas plantillas de email en emailService.js.
            *   `[x ]` Una plantilla de alerta de seguridad para el email antiguo ("Se ha solicitado un cambio de email...").
            *   `[x ]` Una plantilla de verificación para el email nuevo ("Confirma tu nueva dirección de email...").
    *   `[ ]` **AUTH-13.2:** Implementar el Endpoint de Re-autenticación
        *   `[ ]` Crear la ruta POST /api/perfil/verify-password en perfilRoutes.js. Debe estar protegida por protegeRuta.
            *   `[ ]` Implementar la lógica en perfilController.verifyPassword. Esta funcion:
                *   `[ ]` Recibe la contraseña actual del usuario.
                *   `[ ]` La compara de forma segura (bcrypt.compare) con el hash almacenado en la BD para el usuario req.user.id.
                *   `[ ]` Si la contraseña es correcta, responde con un success: true. Si es incorrecta, responde con un error 401.
    *   `[ ]` **AUTH-13.3:** Implementar el Flujo de Cambio de Email.
        *   `[ ]` Crear la ruta POST /api/perfil/request-email-change en perfilRoutes.js. Protegida por protegeRuta.
            *   `[ ]`  Implementar la lógica en perfilController.requestEmailChange. Esta función:
                *   `[ ]` Recibe el nuevo email.
                *   `[ ]` Verifica que el nuevo email no esté ya en uso en la tabla usuarios.
                *   `[ ]` Genera un token de cambio (tokenPlano, tokenHasheado) y una fecha de expiración (ej. 15 minutos).
                *   `[ ]` Guarda el nuevo_email_pendiente, token_cambio_email (hasheado) y la expiración en el registro del usuario.
                *   `[ ]` ncola dos trabajos en la cola_de_trabajos:
                    *   `[ ]` Uno para enviar el email de alerta al correo antiguo.
                    *   `[ ]` Otro para enviar el email de verificación al correo nuevo.
                *   `[ ]` Responde con un mensaje de éxito indicando al usuario que revise su nuevo email.
        *   `[ ]` Crear la ruta PÚBLICA POST /api/auth/verify-email-change.
                *   `[ ]` Implementar la lógica en authController.verifyEmailChange. Esta función:
                    *   `[ ]` Recibe el token.
                    *   `[ ]` ashea el token y busca un usuario que tenga ese token_cambio_email y que no haya expirado.
                    *   `[ ]` Si se encuentra, actualiza el email del usuario al valor de nuevo_email_pendiente.
                    *   `[ ]` Limpia las tres columnas temporales (nuevo_email_pendiente, token_cambio_email, token_cambio_email_expira).
                    *   `[ ]` Importante: Considerar si se debe invalidar las sesiones existentes (implementando la lógica de jwt_version del ADR-009 aquí sería ideal).
                    *   `[ ]` Responde con un mensaje de éxito confirmando el cambio de email.
*   `[x]` **AUTH-14 (Seguridad):** Implementar Protección contra Fuerza Bruta.
    *   `[x]` Instalar y configurar express-rate-limit en el endpoint de login.
    *   `[x]` Implementar lógica de bloqueo de cuenta tras X intentos fallidos.
    *   `[x]` Añadir validación de fortaleza de contraseña en el backend.
* Epopeya AUTH-B: Gestión de Perfil de Usuario
*    `[x]` **PERFIL-01:** Endpoint GET /api/perfil/me para obtener los datos completos del usuario logueado.
*    `[x]` **PERFIL-02:** Endpoint PATCH /api/perfil/me para actualizar datos personales (nombre, teléfono).
*    `[x]` **PERFIL-03:** Flujo para vincular una cuenta de Google a una cuenta activa.
*    `[x]` **PERFIL-04:** Flujo para desvincular una cuenta de Google.

# =================================================================================
# ||     Epopeya 2: Panel del Dueño (Gestión del SaaS)     `[EN PROGRESO]`         ||
# =================================================================================
# || Objetivo: Dar al Dueño las herramientas para gestionar el negocio.          ||
# ---------------------------------------------------------------------------------
*   `[x]` **OWNER-01:** Flujo de Onboarding de Clientes (Recibir, Listar y Aprobar Solicitudes).
*   `[ ]` **OWNER-02:** Gestión de Edificios (Creación implementada, pendiente Leer/Actualizar/Borrar).
    *   `[ ]` **OWNER-02.1:** Implementar el CRUD completo para Edificios (GET, PATCH, DELETE).
*   `[ ]` **OWNER-03:** CRUD completo para Licencias (`/api/dueño/licencias`).
*   `[ ]` **OWNER-04:** Dashboard del Dueño (Endpoints de agregación para métricas).
*   `[ ]` **OWNER-05:** Módulo de Noticias Globales.
*   `[ ]` **OWNER-06:** Herramienta de Soporte Nivel 2 (SQL Runner).
*   `[ ]` **OWNER-07:** Módulo CMS Landing Page (Endpoints CRUD para gestionar contenido y estructura de la página principal).

# =================================================================================
# ||     Epopeya 3: Panel del Administrador (Configuración)     `[COMPLETADA]`   ||
# =================================================================================
# || Objetivo: Dar al Admin las herramientas para modelar su condominio.         ||
# ---------------------------------------------------------------------------------
*   `[x]` **ADMIN-00:** Crear el mecanismo de estados que obliga al administrador a configurar su edificio en un orden lógico.
*   `[x]` **ADMIN-01:** Gestión de Unidades Habitacionales (Generador Flexible Masivo).
*   `[x]` **ADMIN-02:** Gestión de Tipos de Recurso (CRUD completo).
*   `[x]` **ADMIN-03:** Gestión de Inventario de Recursos (Generador Secuencial y Carga por Archivo).
*   `[x]` **ADMIN-04:** Asignación de Recursos (API Masiva para vincularlos a Unidades).
*   `[x]` **ADMIN-05:** Endpoints de lectura para la configuración (Listar Unidades y Recursos).

# =================================================================================
# ||     Epopeya 4: El Núcleo Financiero (Admin y Residente)     `[PENDIENTE]`     ||
# =================================================================================
# || Objetivo: Construir el motor que gestiona las finanzas del condominio.      ||
# ---------------------------------------------------------------------------------
*   `[ ]` **FIN-01:** Gestión de Cuentas Bancarias del Condominio (CRUD del Admin).
*   `[ ]` **FIN-02:** Gestión de Gastos (CRUD del Admin).
*   `[ ]` **FIN-03:** Generación de Recibos de Condominio (El "Cerebro" del Sistema).
*   `[ ]` **FIN-04:** Flujo de Pagos del Residente (Ver Deudas y Reportar Pagos).
*   `[ ]` **FIN-05:** Conciliación de Pagos (Herramienta del Admin).
*   `[ ]` **FIN-06:** Gestión de Multas (CRUD del Admin).
*   `[ ]` **FIN-07:** Módulo Contable de Partida Doble (`plan_de_cuentas`, `asientos`, `movimientos`).

# =================================================================================
# ||     Epopeya 5: Comunidad y Participación     `[PENDIENTE]`                   ||
# =================================================================================
# || Objetivo: Construir las herramientas de interacción comunitaria.            ||
# ---------------------------------------------------------------------------------
*   `[ ]` **COM-01:** Módulo de Noticias y Anuncios del Condominio.
*   `[ ]` **COM-02:** Foro de Discusiones (Hilos y Respuestas).
*   `[ ]` **COM-03:** Módulo Unificado de Consultas (Encuestas, Votaciones y Elecciones).
*   `[ ]` **COM-04:** Gestión de Áreas Comunes (CRUD del Admin).
*   `[ ]` **COM-05:** Módulo de Reservas de Áreas Comunes (Flujo del Residente).

# =================================================================================
# ||     Epopeya 6: Soporte y Automatización     `[PENDIENTE]`                   ||
# =================================================================================
# || Objetivo: Implementar herramientas de soporte y el motor de automatización. ||
# ---------------------------------------------------------------------------------
*   `[ ]` **SUPPORT-01:** Sistema de Incidencias Jerárquico (Residente -> Admin -> Dueño).
*   `[ ]` **SUPPORT-02:** Gestión de Cartas y Documentos (Solicitud y Emisión).
*   `[ ]` **AUTO-01:** Motor de Reglas (CRUD y `RuleEngineService`).
*   `[ ]` **AUTO-02:** Módulo de Auditoría (`AuditService` y registro de acciones).
*   `[ ]` **AUTO-03 (Mejora):** Extender el motor de generación de unidades para soportar placeholders de contador global ({c}, {C}, etc.) (ADR-007).

# =================================================================================
# ||     Epopeya 7: Panel del Residente     `[PENDIENTE]`                       ||
# =================================================================================
# || Objetivo: Proporcionar al Residente todas las herramientas necesarias para  ||
# ||           gestionar su participación en el condominio.                      ||
# ---------------------------------------------------------------------------------
*   `[ ]` **RESIDENTE-01:** Dashboard - Endpoint de agregación para la vista principal del residente.
*   `[ ]` **RESIDENTE-02:** Módulo Pagos - Endpoint para reportar pagos de condominio o reserva.
*   `[ ]` **RESIDENTE-03:** Módulo Reservas - CRUD para solicitar, ver y cancelar reservas de áreas comunes.
*   `[ ]` **RESIDENTE-04:** Módulo Votaciones/Encuestas - Endpoint para emitir votos/respuestas.
*   `[ ]` **RESIDENTE-05:** Módulo Discusiones - Utilizar endpoints del foro para participar.
*   `[ ]` **RESIDENTE-06:** Módulo Elecciones - Endpoints para postularse y emitir votos.
*   `[ ]` **RESIDENTE-07:** Módulo Solicitud de Cartas - Endpoint para solicitar documentos.
*   `[ ]` **RESIDENTE-08:** Módulo Reporte de Incidencias - Endpoint para reportar problemas al administrador.

# =================================================================================
# ||     Epopeya 7: Seguridad Avanzada y Hardening del Sistema     `[PENDIENTE]` ||
# =================================================================================
# || Objetivo: Reforzar la postura de seguridad de LifeBit más allá de lo básico, ||
# ||           protegiendo contra ataques avanzados y mejorando la resiliencia.  ||
# ---------------------------------------------------------------------------------
*   `[ ]` **SEC-01 (Hardening): Cabeceras de Seguridad HTTP.**
    *   `[ ]` Instalar y configurar el middleware `helmet` en Express para añadir cabeceras como `Content-Security-Policy`, `X-Frame-Options`, `Strict-Transport-Security`.
*   `[ ]` **SEC-02 (Anti-Fuerza Bruta): Limitación de Tasa y Bloqueo de Cuentas.**
    *   `[ ]` Instalar y configurar `express-rate-limit` en endpoints de autenticación (`/login`, `/forgot-password`).
    *   `[ ]` Implementar lógica de bloqueo de cuenta tras un número configurable de intentos fallidos por email/IP.
    *   `[ ]` Implementar validación de fortaleza de contraseña en el backend (`finalizarRegistro`, `resetPassword`, `updateMyPassword`).
*   `[ ]` **SEC-03 (2FA/OTP): Verificación por SMS (One-Time Password).**
    *   `[ ]` Integrar un proveedor de SMS Gateway (ej. Twilio).
    *   `[ ]` Construir el flujo para que los usuarios verifiquen y gestionen su número de teléfono.
    *   `[ ]` Implementar OTP como segundo factor de autenticación opcional en el login y para acciones críticas (ej. traspaso de poder).
*   `[ ]` **SEC-04 (XSS): Saneamiento de Contenido Enriquecido.**
    *   `[ ]` Instalar y configurar una librería como `sanitize-html`.
    *   `[ ]` Implementar el saneamiento de cualquier texto enriquecido (HTML) proveniente del usuario antes de guardarlo en la base de datos (ej. foros, noticias).

# =================================================================================
# ||     Epopeya 9 (Futura): Mantenimiento y Escalabilidad     `[PENDIENTE]`     ||
# =================================================================================
# || Objetivo: Realizar mejoras técnicas y preparar la aplicación para el crecimiento. ||
# ---------------------------------------------------------------------------------
*   `[ ]` **MAINT-01 (Refactor):** Migrar el Servicio de Email a Amazon SES.
    *   `[ ]` Obtener y configurar credenciales de AWS SES.
    *   `[ ]` Refactorizar 'emailService.js' para usar el SDK de AWS.
    *   `[ ]` Adaptar la construcción del 'payload' al formato requerido por SES.
    *   `[ ]` Actualizar las variables de entorno en producción.
*   `[ ]` **MAINT-02 (Refactor):** Implementar el modelo de 'afiliaciones' (ADR-001).





# =================================================================================
# ||     ADRs (Architecture Decision Records)     ||
# =================================================================================

ADR-007: Introducción de Placeholders de Contador Global
Título: ADR-007: Introducción de Placeholders de Contador Global para el Generador de Unidades
Fecha: 2025-08-18
Estado: Propuesto
Contexto:
El motor de generación de unidades actual (POST /api/admin/unidades/generar-flexible) utiliza placeholders que se resetean en cada "nivel principal" (definido por totalPisos). Por ejemplo, {u} se reinicia a 1 en cada nuevo piso. Durante las pruebas de UX en el frontend, se identificó un caso de uso crítico que el sistema actual no soporta: propiedades (como conjuntos de casas o galpones) donde la numeración de las unidades es consecutiva a lo largo de toda la propiedad, sin reiniciarse en cada "calle" o "manzana".
Problema:
La interfaz de usuario del frontend está limitada por la capacidad del backend. Para ofrecer una solución verdaderamente flexible, el motor de generación del backend necesita ser capaz de manejar contadores que no se reseteen, sino que se incrementen globalmente a través de todos los niveles.
Decisión:
Se ha decidido extender la funcionalidad del motor de generación del backend para que soporte un nuevo conjunto de placeholders de "contador global".
Nuevos Placeholders a Implementar en el Backend:
{c}: Contador global numérico simple (ej: 1, 2, ..., 30).
{C}: Contador global numérico con 2 dígitos (ej: 01, 02, ..., 30).
{L_c}: Contador global alfabético (ej: A, B, ..., AD).
Lógica de Implementación Propuesta (Backend):
El servicio del generador en el backend deberá mantener una variable de contador acumulativo. Este contador se inicializará en 1 antes de que comiencen los bucles de "piso" y se incrementará en 1 por cada unidad generada, independientemente del piso en el que se encuentre. Los nuevos placeholders se reemplazarán usando el valor de este contador global.
Consecuencias:
Backend: Se requiere una modificación en el servicio de generación de unidades para implementar la lógica del nuevo contador y los nuevos reemplazos de placeholders.
Frontend: El desarrollo de la interfaz de usuario para los bloques de "Contador Global" queda bloqueado hasta que el backend implemente esta funcionalidad. Podemos construir la UI de forma aislada, pero la integración final dependerá de este cambio en la API.
Beneficios: Esta mejora transformará el generador de una herramienta específica para edificios a una herramienta de generación de secuencias genérica y mucho más potente, ampliando significativamente los tipos de propiedades que LifeBit puede gestionar "listo para usar".

ADR-008: Reorganización y Corrección del Roadmap V2
Título: ADR-008: Reorganización y Corrección del Roadmap V2 para Alinear con Linear Local
Fecha: 2025-10-01
Estado: Implementado
Contexto:
Durante la integración con Linear Local (`gestion_proyectos_local.md`), se identificaron inconsistencias en la numeración de epopeyas, duplicados en tareas de seguridad, y falta de alineación con asignaciones de IA y estándares de AGENTS.md.
Problema:
El roadmap V2 tenía numeración inconsistente (Epopeya 2 como Seguridad en lugar de Panel Dueño), duplicados (SEC-02 similar a AUTH-14, MAINT-03 similar a SEC-03), y no coincidía con las epics en Linear Local (EPIC-001 a EPIC-009).
Decisión:
Se decidió reorganizar el roadmap para:
- Alinear numeración de epopeyas con Linear Local (Epopeya 0-9).
- Mover seguridad avanzada a Epopeya 8.
- Eliminar duplicados e integrar elementos repetidos.
- Asegurar consistencia con diffs aplicados, asignaciones IA y protocolos de AGENTS.md.
Funcionalidades Reorganizadas:
- Epopeya 2: Panel del Dueño (mantenido).
- Epopeya 3: Panel Admin (renumerado).
- Epopeya 4: Núcleo Financiero (renumerado).
- Epopeya 5: Comunidad (renumerado).
- Epopeya 6: Soporte y Automatización (renumerado, incluye auditoría).
- Epopeya 7: Panel Residente (renumerado).
- Epopeya 8: Seguridad Avanzada (nueva, consolida elementos de seguridad).
- Epopeya 9: Mantenimiento (limpia duplicados).
Consecuencias:
Backend/Frontend: Requiere actualización de referencias en código y docs.
Linear Local: Ahora coincide perfectamente con roadmap.
Beneficios: Roadmap consistente, sin duplicados, alineado con gestión de proyectos IA y estándares de calidad.

ADR-009: Mejoras Avanzadas de Seguridad y Optimización en Autenticación
Título: ADR-009: Mejoras Avanzadas de Seguridad y Optimización en el Sistema de Autenticación
Fecha: 2025-10-06
Estado: Propuesto
Contexto:
Tras la implementación de la autenticación básica en LifeBit, se han identificado oportunidades para fortalecer la seguridad contra amenazas avanzadas como replay de tokens, ataques CSRF, robo de sesiones compartidas, y mejorar la auditoría y optimización del sistema.
Problema:
El sistema actual carece de protecciones contra ciertos vectores de ataque comunes en aplicaciones web, como la reutilización de refresh tokens, ataques CSRF si se usan cookies, invalidación de tokens al cambiar contraseñas, y falta de logging detallado para auditoría. Además, hay oportunidades de optimización en consultas de base de datos y caching para mejorar el rendimiento.
Decisión:
Se decide implementar las siguientes mejoras en el sistema de autenticación, consolidando elementos no duplicados con el roadmap existente:
- Implementar "token rotation" para refresh tokens: cada refreshToken válido genera uno nuevo y anula el anterior.
- Añadir protección CSRF si el frontend usa cookies, mediante tokens CSRF en encabezados.
- Implementar jwt_version en la tabla usuarios para invalidar tokens viejos al cambiar contraseña, previniendo robo de sesión compartida.
- Integrar pino para logging de IPs, agentes de usuario, fallos de login, etc., para auditoría.
- En register(), usar email.toLowerCase() antes de insertar para evitar duplicados por sensibilidad a mayúsculas.
- En login(), añadir campo last_login al usuario para registrar la última sesión.
- En protegeRuta(), cachear temporalmente el usuario validado para evitar consultas repetidas.
- En authQueries.js y usuarioQueries.js, añadir LIMIT 1 en queries que devuelven un solo usuario y crear vistas (ej. v_usuarios_token) para consultas complejas.
Consecuencias:
Backend: Requiere modificaciones en authController.js, middlewares de autenticación, queries de usuario y auth, y posiblemente la base de datos (añadir campos jwt_version, last_login). Integración de pino para logging.
Frontend: Si se implementa CSRF, puede requerir ajustes en el envío de requests.
Beneficios: Mayor robustez contra ataques avanzados, mejor trazabilidad con logging, optimización de rendimiento en consultas frecuentes, y prevención de vulnerabilidades comunes, elevando la postura de seguridad general de LifeBit.